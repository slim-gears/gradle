import org.gradle.api.internal.artifacts.dependencies.AbstractDependency
import org.gradle.api.internal.artifacts.dependencies.SelfResolvingDependencyInternal

import java.nio.file.Paths

def signingEnabled = project.ext.hasProperty('signing.secretKeyRingFile')
if (signingEnabled) {
    def keyRingFilePath = Paths.get(project.ext.'signing.secretKeyRingFile')
    if (!keyRingFilePath.isAbsolute()) {
        project.ext.'signing.secretKeyRingFile' = "$rootProject.projectDir/$keyRingFilePath"
    }
}

apply plugin: 'maven-publish'
apply plugin: 'signing'

publishing {
    repositories {
        mavenLocal()
    }
}

signing {
    required { signingEnabled }
}

ext.getArtifactId = { SourceSet sourceSet ->
    sourceSet.name == 'main' ? project.name : "$project.name-$sourceSet.name"
}


ext.addPublication = { SourceSet sourceSet  ->

    def sourceSetName = sourceSet.name

    def sourcesJarTask = project.tasks.create(name: "${sourceSetName}SourcesJar", type: Jar) {
        from sourceSet.allSource
        archiveClassifier.value 'sources'
    }

    def javaDocJarTask = project.tasks.create(name: "${sourceSetName}JavaDocJar", type: Jar) {
        from javadoc
        archiveClassifier.value 'javadoc'
    }

    def jarTask = sourceSetName.equals('main') ? jar : project.tasks.create(name: "${sourceSetName}Jar", type: Jar, dependsOn: sourceSet.classesTaskName) {
        from sourceSet.output
        def artifactId = project.getArtifactId(sourceSet)
        archiveBaseName.value artifactId
    }

    project.artifacts {
        archives jarTask
        archives javaDocJarTask
        archives sourcesJarTask
    }

    return project.publishing.publications.create("${sourceSetName}Maven", MavenPublication) {
        it.groupId = project.group
        it.artifactId = project.getArtifactId(sourceSet)
        it.artifact sourcesJarTask
        it.artifact jarTask
        it.artifact javaDocJarTask

        it.pom {
            def projectUrl = "https://github.com/$projectUrlPath"
            def scmConnection = "scm:git:git://github.com/${projectUrlPath}.git"
            def scmDeveloperConnection = "scm:git:ssh://git@github.com/${projectUrlPath}.git"

            name = "$rootProject.name / $project.name"
            description = "$projectDescription / module: $project.name"
            url = projectUrl
            licenses {
                license {
                    name = projectLicense
                    url = "$projectUrl/blob/master/LICENSE"
                    distribution = 'repo'
                }
            }
            scm {
                url = projectUrl
                connection = scmConnection
                developerConnection = scmDeveloperConnection
            }
            issueManagement {
                system = 'GitHub'
                url = "$projectUrl/issues"
            }
            developers {
                developer {
                    id = developerId
                    name = developerName
                    email = developerEmail
                }
            }
        }

        it.pom.withXml {
            def rootNode = it.asNode()
            def depsNode = rootNode.appendNode('dependencies')
            def dependencies = configurations.getByName(sourceSet.implementationConfigurationName).allDependencies
            dependencies
                    .findAll { it.group != null && it.name != null }
                    .forEach {
                def depNode = depsNode.appendNode('dependency')
                depNode.appendNode('groupId', it.group)
                depNode.appendNode('artifactId', it.name)
                depNode.appendNode('version', it.version)

                if (it.hasProperty('excludeRules') && !it.excludeRules.isEmpty()) {
                    def exclusionsNode = depNode.appendNode('exclusions')
                    it.excludeRules.each { rule ->
                        def exclusionNode = exclusionsNode.appendNode('exclusion')
                        exclusionNode.appendNode('groupId', rule.group)
                        exclusionNode.appendNode('artifactId', rule.module)
                    }
                }
            }
        }
    }
}

class SourceSetDependency extends AbstractDependency implements FileCollectionDependency, SelfResolvingDependencyInternal {
    private final Project project
    private final SourceSet sourceSet

    SourceSetDependency(Project project, SourceSet sourceSet) {
        this.project = project
        this.sourceSet = sourceSet
    }

    SourceSetDependency(Project project, String sourceSetName) {
        this(project, project.sourceSets.getByName(sourceSetName))
    }

    @Override
    FileCollection getFiles() {
        return sourceSet.output
    }

    @Override
    Set<File> resolve() {
        return sourceSet.output.files
    }

    @Override
    Set<File> resolve(boolean transitive) {
        return sourceSet.output.files
    }

    @Override
    String getGroup() {
        return project.group
    }

    @Override
    String getName() {
        return project.getArtifactId(sourceSet)
    }

    @Override
    String getVersion() {
        return project.version
    }

    @Override
    boolean contentEquals(Dependency dependency) {
        if (!(dependency instanceof SourceSetDependency)) {
            return false
        }

        SourceSetDependency sourceSetDep = (SourceSetDependency)dependency
        return this.project == sourceSetDep.project && this.sourceSet == sourceSetDep.sourceSet
    }

    @Override
    Dependency copy() {
        return new SourceSetDependency(project, sourceSet)
    }

    @Override
    ComponentIdentifier getTargetComponentId() {
        return null
    }

    @Override
    TaskDependency getBuildDependencies() {
        return null
    }
}

def sourceSetDependency(SourceSet sourceSet) {
    return new SourceSetDependency(project, sourceSet)
}

def sourceSetDependency(String sourceSet) {
    return new SourceSetDependency(project, sourceSet)
}

project.ext.sourceSetDependency = this.&sourceSetDependency

project.ext.publishSourceSets = { sourceSets ->
    sourceSets.findAll { it.name != 'test' && it.name != 'generated' }.each {
        def publication = project.addPublication(it)
        project.signing.sign publication
    }
}

project.afterEvaluate {
    if (project.hasProperty('sourceSets')) {
        project.publishSourceSets(project.sourceSets)
    }
}


task install(type: DefaultTask, dependsOn: publishToMavenLocal)
